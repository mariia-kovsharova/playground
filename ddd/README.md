**DDD** - подход к проектированию архитектуры, где приложение разделяется на три основных слоя: домен, прикладной слой сервисов и адапетры.

#### Структура

##### Домен - сердце приложения.

Это те сущности и данные, которые описывают предметную область приложения, а также код для преобразования эти данных. Домен — это ядро, которое отличает одно приложение от другого.
Бизнес сущность может содержать в себе не только какие-то свойства (быть DTO), но и содержать в себе какую-то логику (то есть, это классический класс и методы класса).
**Бизнес-сущности не должны знать про какие-то внешние сервисы и прочее, они не должны быть зависимы от каких-то сторонних библиотек.**

О домене можно думать, как о том, что точно не поменяется, если мы будем переезжать с React на Angular, или если изменим какой-то пользовательский сценарий.

Структура данных доменных сущностей и суть их преобразований не зависит от внешних обстоятельств. Внешние обстоятельства запускают доменные преобразования, но не определяют, как они будут протекать (вспоминаем паттерн `Command` - один объект знает что делать, но не знает, когда; второй объект не знает, что сделать, но знает, когда; вместе они составляют пару, в которой один является триггером для второго, то есть управляющий объект запускает через команду код в управляемом объекте).

```
class TodoItem {
    private _id: string;

    public name: string;
    public description: string;
    public isCompleted: boolean;

    constructor(name: string, description: string) {
        this.name = name;
        this.description = description;
        this.isCompleted = false;
    }

    get id(): string {
        return this._id;
    }

    toggle(): void {
        this.isCompleted = !this.isCompleted;
    }
}
```

Сюда можно еще добавить слой **Domain Service**.

Доменный сервис реализует бизнес-логику, которая не принадлежит ни одной конкретной сущности (агрегату) или группе сущностей в доменной модели. Например, он может реализовывать сложные расчеты при участии нескольких бизнес-сущностей.

**Пример** - расчет скидок на основе сложных правил, выполнение междоменных операций, таких как проверка кредитоспособности.

Предположим, что я хочу использовать библиотеку uuid для генерации идентификатора. По причине того, что TodoItem - часть домена, я не могу использовать эту зависимость напрямую.

Для того, чтобы решить эту задачу, я могу использовать прикладной слой и слой приложения, но это означает, что в моей доменной сущности идентификатор будет получен сверху

```
    constructor({ id, name, description }: { id: string; name: string; description: string }) {
        this._id = id;
        this.name = name;
        this.description = description;
        this.isCompleted = false;
    }

```

##### Прикладной слой

Вокруг домена расположен прикладной слой. Он содержит в себе несколько аспектов.

**UseCases**
В этом слое описываются юзкейсы — то есть пользовательские сценарии. Они отвечают за то, что происходит после возникновения какого-то события.
**Ports**
Также в прикладном слое находятся порты — спецификации того, как наше приложение хочет, чтобы с ним общался внешний мир. Обычно порт — это интерфейс, контракт на поведение.

-   Входные порты (Input Ports) говорят, как приложение хочет, чтобы к нему обращались извне.
-   Выходные порты (Output Ports) говорят, как приложение собирается общаться с внешним миром, чтобы тот был готов к этому.

Порты могут быть обозначены также для процессов, которые будут выполняться сторонним кодом - это могут быть генерации идентификаторов, работа с датами и т.д. Прикладной слой будет работать с интерфейсами, а не с конкретной реализацией - это значит, что в любой момент мы можем изменить библиотеку, используемую для работы, но сделаем это ровно в одном месте, в месте определения реализации интерфейса.

```
export interface UuidGeneratorService {
    generate(): string;
}

export interface DateService {
    createDateFromString(value: string): Date;
    getDays(date: Date): number;
    getDifference(firstDate: Date, secondDate: Date): number;
    addDays(date: Date, amount: number): Date;
}
```

Провайдинг сервисов в прикладной слой можно осуществить с помощью механизма Dependency Injection (DI).

Пример use case по созданию TodoItem с помощью DI:

```
export class CreateTodoUseCase {
    private uuidGenerator: UuidGeneratorService;

    // С помощью DI получаем здесь инстанс UuidGeneratorService
    constructor(uuidGenerator: UuidGeneratorService) {
        this.uuidGenerator = uuidGenerator;
    }

    execute(name: string, description: string): TodoItem {
        const id = this.uuidGenerator.generate();

        const todo = new TodoItem({
            id,
            name,
            description,
        });

        return todo;
    }
}
```

или в случае, если use case просто функция

```
interface CreateTodoUseCaseParams {
    name: string;
    description: string;
}

interface CreateTodoUseCaseDependencies {
    uuidGenerator: UuidGeneratorService;
}

export function createTodoUseCase(
    params: CreateTodoUseCaseParams,
    deps: CreateTodoUseCaseDependencies
): TodoItem {
    const { name, description } = params;
    const id = deps.uuidGenerator.generate();

    const todo = new TodoItem({
        id,
        name,
        description,
    });

    return todo;
}
```

##### Адаптеры

Адаптеры нужны, чтобы превращать несовместимое API внешних сервисов в совместимое с тем, как мы хотим работать в нашем приложении - мы не должны подстраивать свое приложение под интерфейсы внешних сервисов, мы должны взаимодействовать с ними так, как удобно нам.

Адаптеры делят на:

управляющие (driving) — которые посылают сигналы нашему приложению;
управляемые (driven) — которые получают сигналы от нашего приложения.

Управляющий адаптер - это UI или ввод пользователем команды в терминале. Это какое-то внешнее событие, которое запускает работу внутри самого приложения.

Управляемые адаптеры взаимодействуют с инфраструктурой. Это может быть запрос к бекенд-серверу, взаимодействие со сторонним сервисом (отправка данных и т.д.)

`outer event => application => infrastructure event`

#### Правило зависимостей

У трёхслойной архитектуры есть правило зависимостей: только внешние слои могут зависеть от внутренних. Это значит, что:

-   домен должен быть независим;
-   прикладной слой может зависеть от домена;
-   внешние слои могут зависеть от чего угодно.

#### Структура приложения

Лучше всего делить приложение по бизнес-слайсам - **feature-sliced** подход.
В таком случае для каждой фичи создается папка, в которой будет следующий набор директорий.
